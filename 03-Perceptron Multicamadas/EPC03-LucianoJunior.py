# -*- coding: utf-8 -*-
"""EPC03.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pceePQR2g_GBtsqdixMhPBW3c6qfaTGw
"""

import numpy as np
import time

from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier

##Função de ler dados##
def ler_data(dataset):
  arquivo= open(dataset)
  dados=[]
  aux_x=[]
  aux_y=[]
  for linha in arquivo.readlines():
    dados.append(linha.split(', '))

  for i in range(9, len(dados)-1):
    aux_x.append([dados[i][0], dados[i][1], dados[i][2], dados[i][3]])
    aux_y.append(converter(dados[i][4]))

  return (aux_x,aux_y)

###FUNÇÃO CONVERTER###
def converter(y):
  if "Iris-setosa\n"==y:
    return 0
  elif "Iris-versicolor\n"==y:
    return 1
  elif "Iris-virginica\n"==y:
    return 2

##Sobrepor a classe MLPClassifier para definir os pesos e guardá-los 
##para usar no momentum, também define o bias como 0.5##
class MLPClassifierOverride(MLPClassifier):
  def _initialize(self, y, layer_units):
    global cont
    # set all attributes, allocate weights etc for first call
    # Initialize parameters
    self.n_iter_ = 0
    self.t_ = 0
    self.n_outputs_ = y.shape[1]

    # Compute the number of layers
    self.n_layers_ = len(layer_units)
    self.out_activation_ = 'logistic'

    # Initialize coefficient and intercept layers
    if self.momentum==0:
      self.coefs_ = []
      self.intercepts_ = []

      for i in range(self.n_layers_ - 1):
        coef_init, intercept_init = self._init_coef(layer_units[i],
                                                    layer_units[i + 1])
        self.coefs_.append(coef_init)
        self.intercepts_.append(intercept_init)

      vet_pesos.append(self.coefs_)
    else:
      self.coefs_ = []
      self.intercepts_ = []

      for i in range(self.n_layers_ - 1):
        coef_init, intercept_init = self._init_coef(layer_units[i],
                                                    layer_units[i + 1])
        self.coefs_.append(coef_init)
        self.intercepts_.append(intercept_init)

      self.coefs_.clear()
      self.coefs_=vet_pesos[cont].copy()
      cont+=1

    self.loss_curve_ = []
    self._no_improvement_count = 0
    if self.early_stopping:
      self.validation_scores_ = []
      self.best_validation_score_ = -np.inf
    else:
      self.best_loss_ = np.inf


  def _init_coef(self, fan_in, fan_out):
    coef_init = self._random_state.uniform(0, 1, (fan_in, fan_out))
    intercept_init = []
    for i in range(fan_out):
      intercept_init.append(0.5)
    return coef_init, intercept_init


#Global
scaler = MinMaxScaler()
mlp = MLPClassifierOverride(hidden_layer_sizes=(7,10), activation='logistic',
                            solver='sgd', learning_rate_init=0.1, 
                            max_iter=9999999999, shuffle=False, 
                            tol=10**-6, momentum=0)

mlp_momentum = MLPClassifierOverride(hidden_layer_sizes=(7,10), activation='logistic',
                                     solver='sgd', learning_rate_init=0.1, 
                                     max_iter=9999999999, shuffle=False, 
                                     tol=10**-6, momentum=0.9)

cont=0
vet_pesos=[]

"""SEM MOMENTUM"""

#INICIO SEM MOMENTUM##
eqms=[]
acuracia=[]
tempo=[]
epocas=[]
for i in range(10):
  eqms.append([])
  acuracia.append([])
  tempo.append([])
  epocas.append([])
  X=[]
  y=[]
  #LER OS DADOS
  X, y= ler_data('iris-10-'+str(i+1)+'tra.dat')
  X= scaler.fit_transform(X)
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)
  for j in range(3):
    start = time.time()#inicia contador de tempo 
    mlp.fit(X_train,y_train)
    end = time.time() #fim do contador
    eqms[i].append(mlp.loss_)
    tempo[i].append(end-start)
    epocas[i].append(mlp.n_iter_)
    acuracia[i].append(mlp.score(X_test, y_test))

print("Média EQM: ", np.mean(eqms), "     Desvio Padrão: ", np.std(eqms))   
print("Média Épocas: ", np.mean(epocas), "     Desvio Padrão: ", np.std(epocas))   
print("Média Tempo: ", np.mean(tempo), "     Desvio Padrão: ", np.std(tempo))   
print("Média Acurácia: ", np.mean(acuracia), "     Desvio Padrão: ", np.std(acuracia))

"""Com momentum"""

#INICIO COM MOMENTUM##
eqms=[]
acuracia=[]
tempo=[]
epocas=[]
for i in range(10):
  eqms.append([])
  acuracia.append([])
  tempo.append([])
  epocas.append([])
  X=[]
  y=[]
  #LER OS DADOS
  X, y= ler_data('iris-10-'+str(i+1)+'tra.dat')
  X= scaler.fit_transform(X)
  X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)
  for j in range(3):
    start = time.time()#inicia contador de tempo 
    mlp_momentum.fit(X_train,y_train)
    end = time.time() #fim do contador
    eqms[i].append(mlp_momentum.loss_)
    tempo[i].append(end-start)
    epocas[i].append(mlp_momentum.n_iter_)
    acuracia[i].append(mlp_momentum.score(X_test, y_test))

print("Média EQM: ", np.mean(eqms), "     Desvio Padrão: ", np.std(eqms))   
print("Média Épocas: ", np.mean(epocas), "     Desvio Padrão: ", np.std(epocas))   
print("Média Tempo: ", np.mean(tempo), "     Desvio Padrão: ", np.std(tempo))   
print("Média Acurácia: ", np.mean(acuracia), "     Desvio Padrão: ", np.std(acuracia))

"""Testes"""

#INICIO TESTES##
temposm=[]
eqmsm=[]
acuraciasm=[]
tempocm=[]
eqmcm=[]
acuraciacm=[]
for i in range(10):
  X_train=[]
  y_train=[]
  X_test=[]
  y_test=[]
  #LER OS DADOS
  X_train, y_train= ler_data('iris-10-'+str(i+1)+'tra.dat')
  X_test, y_test= ler_data('iris-10-'+str(i+1)+'tst.dat')

  X_train= scaler.fit_transform(X_train)
  X_test= scaler.fit_transform(X_test)

  #SEM MOMENTUM
  start = time.time()#inicia contador de tempo 
  mlp.fit(X_train,y_train)
  end = time.time() #fim do contador
  temposm.append(end-start)
  eqmsm.append(mlp.loss_curve_)
  acuraciasm.append(mlp.score(X_test, y_test))

  #COM MOMENTUM
  start = time.time()#inicia contador de tempo 
  mlp_momentum.fit(X_train,y_train)
  end = time.time() #fim do contador
  tempocm.append(end-start)
  eqmcm.append(mlp_momentum.loss_curve_)
  acuraciacm.append(mlp_momentum.score(X_test, y_test))

"""Gráficos"""

from matplotlib import pyplot as plt
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10,5))

ax1.plot(eqmsm[2])
ax2.plot(eqmcm[2])

ax1.set(title="Sem Momentum", xlabel="Época", ylabel="EQM")
ax2.set(title="Com Momentum", xlabel="Época", ylabel="EQM")
plt.show()

print("Tempo sem Momentum: ", temposm[2])
print("Tempo com Momentum: ", tempocm[2])

"""Acuracias dos Testes"""

print("Média sem Momentum: ", np.mean(acuraciasm), "     Desvio Padrão: ", np.std(acuraciasm)) 
print("Média com Momentum: ", np.mean(acuraciacm), "     Desvio Padrão: ", np.std(acuraciacm))